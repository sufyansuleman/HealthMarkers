---
title: "BODE Index"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{bode_index}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Scope
Compute the 0-10 BODE score (BMI, Obstruction, Dyspnea, Exercise capacity) from FEV1 % predicted, 6-minute walk distance, mMRC dyspnea, and BMI. Accepts a percent-predicted column or derives it from raw/predicted FEV1. Higher scores indicate worse prognosis.

Component scoring: FEV1% (>=65 -> 0, 50-64 -> 1, 36-49 -> 2, <=35 -> 3); 6MWD meters (>=350 -> 0, 250-349 -> 1, 150-249 -> 2, <=149 -> 3); mMRC (0-1 -> 0, 2 -> 1, 3 -> 2, 4 -> 3); BMI (>21 -> 0, <=21 -> 1).

## When to use
- You have spirometry plus 6MWD, mMRC, and BMI for COPD risk stratification.
- You need optional extreme-value screening and explicit row-retention rules.
- You want to derive FEV1% from raw/predicted FEV1 or use an existing percent-predicted column.

## Requirements checklist
- Packages: HealthMarkers, dplyr (for display).
- Data columns: choose exactly one FEV1 source: fev1_pct OR (fev1 + fev1_pred) OR fev1_pp; plus sixmwd, mmrc, bmi.
- Numeric inputs; non-numeric are coerced with warnings; non-finite become NA.
- Row policy via na_action: keep (default), omit, error; warn/ignore behave like keep but emit messages.
- Optional extreme screening: check_extreme + extreme_action (warn/cap/error/ignore/NA).

## Load packages and example data
Replace the example slice with your data frame.

```{r}
library(HealthMarkers)
library(dplyr)

sim_path <- system.file("extdata", "simulated_hm_data.rds", package = "HealthMarkers")
sim <- readRDS(sim_path)
sim_small <- sim[1:50, ]
```

## Map columns
Here we use FEV1 percent-predicted from the example data.

```{r}
col_map <- list(
  fev1_pct = "FEV1pct",
  sixmwd = "sixmwd",
  mmrc = "mmrc",
  bmi = "BMI"
)
```

## Quick start: compute BODE
Defaults keep rows with missing inputs and return NA for their scores.

```{r}
bode_out <- bode_index(
  data = sim_small,
  col_map = col_map,
  na_action = "keep",
  check_extreme = FALSE,
  extreme_action = "warn",
  verbose = FALSE
)

new_cols <- setdiff(names(bode_out), names(sim_small))
head(select(bode_out, all_of(new_cols)))
```

## Arguments that matter
- col_map: pick one FEV1 source (fev1_pct OR fev1 + fev1_pred OR fev1_pp) plus sixmwd, mmrc, bmi; missing required keys error.
- na_action: keep (default), omit (drop rows with any missing required inputs), error (abort on missing); warn/ignore act like keep but warn.
- check_extreme: FALSE by default; TRUE enables bounds-based screening.
- extreme_action: warn (default, no change), cap, error, ignore, or NA. Defaults (units as stored): fev1_pct 10-140, sixmwd 50-800, mmrc 0-4, bmi 10-60.
- verbose: emit step messages.

## Handling missing inputs
- Non-numeric inputs are coerced; NA introduced are warned. Non-finite become NA.
- Missing required inputs yield NA scores when na_action is keep/warn/ignore; rows drop with omit; error aborts.

### Compare row policies
```{r}
demo <- sim_small
demo$mmrc[c(2, 6)] <- NA

a_keep <- bode_index(demo, col_map, na_action = "keep")
a_omit <- bode_index(demo, col_map, na_action = "omit")

list(
  keep_rows = nrow(a_keep),
  omit_rows = nrow(a_omit),
  sample_scores = head(select(a_keep, bode_index, fev1_score, walk_score, mmrc_score, bmi_score))
)
```

## Extreme-value screening (optional)
Screen inputs before scoring; cap, warn, error, ignore, or set NA for extremes.

```{r}
demo2 <- sim_small
demo2$sixmwd[5] <- 20   # extreme low walk
demo2$BMI[6] <- 80      # extreme high BMI

a_screen <- bode_index(
  data = demo2,
  col_map = col_map,
  na_action = "keep",
  check_extreme = TRUE,
  extreme_action = "cap",
  extreme_rules = list(fev1_pct = c(10, 140), sixmwd = c(50, 800), mmrc = c(0, 4), bmi = c(10, 60)),
  verbose = FALSE
)

head(select(a_screen, bode_index, fev1_score, walk_score, mmrc_score, bmi_score))
```

## Outputs
- bode_index (0-10)
- Component scores: fev1_score, walk_score, mmrc_score, bmi_score
- fev1_pct (derived or mapped)
Rows only drop with na_action = "omit" or when na_action = "error" aborts.

## Pitfalls and tips
- Map exactly one FEV1 source; providing multiple percent-predicted sources is not allowed.
- Keep units consistent: FEV1 in liters when deriving percent, 6MWD in meters, BMI in kg/m^2.
- Use extreme_action = "error" for strict QA; cap for winsorization.
- mMRC must be 0-4; true zeros are valid.
- warn/ignore behave like keep; choose omit or error for strict pipelines.

## Validation ideas
- Spot-check: FEV1% = 40, 6MWD = 200, mMRC = 3, BMI = 20 yields scores 2 + 2 + 2 + 1 = bode_index 7.
- Verify that rows with NA mmrc are retained vs dropped according to na_action.
- Confirm percent-predicted derivation: fev1_pp should match 100 * fev1 / fev1_pred for a test row.

## See also
- spirometry_markers() for broader spirometry-derived metrics.
- pulmo_markers() for additional pulmonary markers.
